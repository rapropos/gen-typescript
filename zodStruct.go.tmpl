{{ define "zodStruct" }}

{{ $name := .Name }}
{{ $fields := .Fields }}
{{ $typeMap := .TypeMap }}
{{ $todoTypes := .TodoTypes }}
{{ $watchedTypes := .WatchedTypes }}

{{- /* ensure referenced types are defined first */}}
{{- range $_, $field := $fields }}
    {{ $fbtn:= trimPrefix $field.Type.Expr "[]"}}
    {{- if hasKey $todoTypes $fbtn }}
    // prioritizing {{$fbtn}} needed for {{$name}}
	    {{ $fbt := get $todoTypes $fbtn }}
		{{- if isEnumType $fbt }}
		    {{- template "zodEnum" dict "Name" $fbtn "Fields" $fbt.Fields "TodoTypes" $todoTypes }}
		{{- else if isStructType $fbt }}
            {{- template "zodStruct" dict "Name" $fbtn "Fields" $fbt.Fields
                "TypeMap" $typeMap "TodoTypes" $todoTypes "WatchedTypes" $watchedTypes }}
		{{- else }}
		// ERROR: {{$fbt}} neither enum nor struct
		{{- end }}
		{{ $_ := unset $todoTypes $fbtn }}
    {{- end }}
{{- end }}

export const {{$name}} = z.object({
{{- range $_, $field := $fields}}
    {{- $isExportable := true }}
    {{- range $meta := $field.Meta }}
        {{- if exists $meta "json" }}
            {{- if eq (printf "%v" (get $meta "json")) "-" }}
                {{- $isExportable = false}}
            {{- end }}
        {{- end }}
    {{- end }}

    {{- if $isExportable }}
        {{template "fieldName" dict "Field" .}}: {{if .Optional}}z.optional({{end}}{{template "zodType" dict "Type" $field.Type "TypeMap" $typeMap}}{{if .Optional}}){{end}},
    {{- end }}
{{- end}}
});

export const {{$name}}Required = z.object({
{{- range $_, $field := $fields}}
    {{- $isExportable := true }}
    {{- range $meta := $field.Meta }}
        {{- if exists $meta "json" }}
            {{- if eq (printf "%v" (get $meta "json")) "-" }}
			    {{- $isExportable = false}}
            {{- end }}
        {{- end }}
    {{- end }}

    {{- if $isExportable }}
    {{template "fieldName" dict "Field" .}}: {{template "zodType" dict "Type" $field.Type "TypeMap" $typeMap}},
    {{- end }}
{{- end}}
});
export type {{$name}}Required = z.infer<typeof {{$name}}Required>;

{{- if hasKey $watchedTypes $name }}
    {{- $fieldNames := dict }}

    {{- range $_, $field := $fields }}
        {{ set $fieldNames $field.Name true }}
    {{- end }}

    {{- if hasKey $fieldNames "id" }}
export const {{$name}}SingleAliveTransition = z.object({
    dlta: z.optional(z.never()),
    next: {{$name}},
});

export const {{$name}}DelTransition = z.object({
    dlta: z.optional(z.never()),
	prev: z.object({id: z.string()}),
	next: z.optional(z.never()),
});

export const {{$name}}ListFullTransition = z.object({
    dlta: z.optional(z.never()),
	prev: z.optional({{$name}}),
	next: z.optional({{$name}}),
}).check(ctx => {
	if (("prev" in ctx.value) && ("next" in ctx.value)) {
		const prevId = ctx.value.prev?.id;
		const nextId = ctx.value.next?.id;
		if (!prevId || !nextId || prevId !== nextId) {
            ctx.issues.push({
                code: "custom",
                message: "prev and next ids must match",
                values: [prevId, nextId],
                input: ctx.value,
            });
        }
    }
});

export const {{$name}}Delta = z.object({
        {{- range $_, $field := $fields}}
            {{- $isExportable := true }}
            {{- range $meta := $field.Meta }}
                {{- if exists $meta "json" }}
                    {{- if eq (printf "%v" (get $meta "json")) "-" }}
                        {{- $isExportable = false}}
                    {{- end }}
                {{- end }}
            {{- end }}

            {{- if $isExportable }}
                {{template "fieldName" dict "Field" .}}: {{if ne $field.Name "id"}}z.optional({{end}}{{template "zodType" dict "Type" $field.Type "TypeMap" $typeMap}}{{if ne $field.Name "id"}}){{end}},
            {{- end }}
        {{- end}}
});

export const {{$name}}DeltaTransition = z.object({
	dlta: z.literal(true),
	prev: {{$name}}Delta,
	next: {{$name}}Delta,
}).check(ctx => {
    if (("prev" in ctx.value) && ("next" in ctx.value)) {
        const prevId = ctx.value.prev.id;
        const nextId = ctx.value.next.id;
        if (prevId !== nextId) {
            ctx.issues.push({
                code: "custom",
                message: "prev and next ids must match",
                values: [prevId, nextId],
                input: ctx.value,
            });
        }
    }
});

export const {{$name}}SingleTransition = z.union([
    {{$name}}SingleAliveTransition, {{$name}}DelTransition, {{$name}}DeltaTransition,
]);

export const {{$name}}ListTransition = z.union([
    {{$name}}ListFullTransition, {{$name}}DeltaTransition,
]);
    {{- end }}
{{- end }}

{{ $_ := unset $todoTypes $name }}
{{- end }}

