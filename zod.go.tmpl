{{ define "zod"}}

{{- $types := .Types }}
{{- $typeMap := .TypeMap }}
{{- $services := .Services }}

{{- $coreZxprMap := dict
    "string" "z.string()"
    "bool" "z.boolean()"
    "int" "z.number()"
    "int16" "z.number()"
    "int32" "z.number()"
    "int64" "z.number()"
    "uint" "z.number()"
    "uint16" "z.number()"
    "uint32" "z.number()"
    "uint64" "z.number()"
    "float32" "z.number()"
    "float64" "z.number()"
    "timestamp" "z.string()"
    "any" "z.any()"
}}

{{/* we need to get members defined before anything that uses them */}}
{{- $todoTypes := dict }}
{{- range $_, $t := $types }}
    {{ $_ := set $todoTypes $t.Name $t }}
{{- end }}

{{- $watchedTypes := dict }}

{{- range $_, $svc := $services }}
    {{- range $_, $meth := $svc.Methods }}
		{{- if hasPrefix $meth.Name "Watch" }}
		    {{ $rt := (index $meth.Outputs 0).Type }}
			{{- if isListType $rt }}
				{{ $rt = $rt.List.Elem }}
			{{- end }}
			{{ set $watchedTypes $rt.Expr $rt }}
		{{- end}}
	{{- end }}
{{- end }}

import {z} from "zod/v4";

type Transition<T> = {
	prev: T;
	next: T;
}

interface Ided {
	id: string;
}

function applyPatch<T extends Ided>(prev: T, trans: Transition<Partial<T>>): Partial<T> {
	const next = structuredClone(prev) as Record<string, any>;
	for (const k in trans.prev) {
		if (k !== "id") {
			// eslint-disable-next-line @typescript-eslint/no-dynamic-delete
			delete (next[k]);
		}
	}
	for (const k in trans.next) {
		if (k !== "id") {
			next[k] = trans.next[k];
		}
	}
	const rv = next as T;
	return rv;
}

function isNukePacket(wpkt: WiredSetlistPacket) {
	return (!("prev" in wpkt) || !wpkt.prev) && (!("next" in wpkt) || !wpkt.next);
}

const Ided = z.object({id: z.string()});

{{- if $types }}
    {{- range $_, $type := $types }}
		{{- if hasKey $todoTypes $type.Name }}
			{{- if isEnumType $type }}
				{{- template "zodEnum" dict "Name" $type.Name "Fields" $type.Fields "TodoTypes" $todoTypes }}
			{{- else if isStructType $type }}
				{{- template "zodStruct" dict
					"Name" $type.Name "Fields" $type.Fields "TypeMap" $coreZxprMap
					"TodoTypes" $todoTypes "WatchedTypes" $watchedTypes }}
			{{- else }}
				// problem {{$type}} neither struct nor enum
			{{- end }}
		{{- end }}
    {{- end }}

export const RpcTypeMap = {
    {{- range $_, $type := $types }}
        {{$type.Name}}: {
			name: "{{$type.Name}}",
			schema: {{$type.Name}},
			deltaTransitionSchema: {{ if hasKey $watchedTypes $type.Name }}{{$type.Name}}DeltaTransition{{else}}undefined{{end}},
        },
    {{- end }}
} as const;
export type RpcType = keyof typeof RpcTypeMap;
{{- end }}

{{- if $services }}
    {{- range $_, $svc := $services }}
	    {{- range $_, $meth := $svc.Methods }}
			// method {{$meth}}
			{{- if gt (len $meth.Inputs) 0 }}
				{{- template "zodStruct" dict
					"Name" (print $meth.Name "Args") "Fields" $meth.Inputs "TypeMap" $coreZxprMap
					"TodoTypes" $todoTypes "WatchedTypes" $watchedTypes }}
			{{- end}}
			{{- if gt (len $meth.Outputs) 0 }}
				{{- template "zodStruct" dict
					"Name" (print $meth.Name "Return") "Fields" $meth.Outputs "TypeMap" $coreZxprMap
					"TodoTypes" $todoTypes "WatchedTypes" $watchedTypes }}
			{{- end}}
		{{- end }}
	{{- end }}

export const RpcVerbMap = {
	{{- range $_, $svc := $services }}
		{{- range $_, $method := $svc.Methods }}
			{{- $isWatcher := false }}
			{{- $verb := $method.Name }}
			{{- if hasPrefix $verb "Watch" }}
				{{ $isWatcher = true }}
				{{ $verb = trimPrefix $verb "Watch" }}
			{{- end }}
			{{- $returnSingleton := "DEADBEEF" }}
			{{- $returnPayloadType := "DEADBEEF" }}
			{{- $returnEnvelope := "DEADBEEF" }}
			{{- $returnElemTypeName := "DEADBEEF" }}
			{{- $setlistPayloadType := "DEADBEEF" }}
			{{- $multiplicity := "" }}
			{{- $returnSchema := "z.never()" }}
			{{- $hasOutput := gt (len $method.Outputs) 0 }}
			{{- if $hasOutput }}
				{{- $returnSingleton = index $method.Outputs 0 }}
				{{- $returnPayloadType = $returnSingleton.Type }}
				{{- $returnEnvelope = $returnSingleton.Name }}
				{{- $returnElemTypeName = trimPrefix $returnSingleton.Type.Expr "[]" }}
				{{- if hasKey $typeMap $returnElemTypeName }}
					{{ $returnElemTypeName = get $typeMap $returnElemTypeName }}
				{{- end }}
				{{- if isListType $returnPayloadType }}
					{{- $setlistPayloadType = $returnPayloadType.List.Elem }}
				{{- else }}
					{{- $setlistPayloadType = $returnPayloadType }}
				{{- end }}
				{{- $multiplicity = ternary (eq $returnElemTypeName $returnSingleton.Type.Expr) "single" "multi" }}
				{{- $returnSchema = print $method.Name "Return" }}
			{{- end }}
			{{- $hasInput := gt (len $method.Inputs) 0 }}

		{{$verb}}: {
			{{- if $hasInput}}
			hasInput: true,
			argsSchema: {{$method.Name}}Args,
			tqkSchema: z.tuple([z.literal("{{$verb}}"), {{$method.Name}}Args]),
			optionalArgTqkSchema: z.tuple([z.literal("{{$verb}}"), z.optional({{$method.Name}}Args)]),
			{{- else }}
			hasInput: false,
			argsSchema: z.undefined(),
			tqkSchema: z.tuple([z.literal("{{$verb}}")]),
			{{end}}

			returnEnvelope: "{{$returnEnvelope}}",
			returnSchema: {{$returnSchema}},

			{{- if $hasOutput }}
			unwrapReturn: (rpc: {{$method.Name}}Return) => rpc.{{$returnEnvelope}},
//			returnLetterSchema: {{template "zodType" dict "Type" $returnSingleton.Type "TypeMap" $coreZxprMap }},
//			returnLetterTypeName: "{{$returnElemTypeName}}",
			{{- else }}
			unwrapReturn: () => undefined,
//			returnLetterSchema: z.never(),
//			returnLetterTypeName: undefined,
			{{- end }}
		},
		{{- end }}
	{{- end }}
} as const;
export type RpcVerb = keyof typeof RpcVerbMap;
export type ArgsSchemaFor<Verb extends RpcVerb> = typeof RpcVerbMap[Verb] extends { argsSchema: unknown }
	? typeof RpcVerbMap[Verb]["argsSchema"] : never;
export type ReturnSchemaFor<Verb extends RpcVerb> = typeof RpcVerbMap[Verb] extends { returnSchema: unknown }
	? typeof RpcVerbMap[Verb]["returnSchema"] : never;
export type TqKey<Verb extends RpcVerb> = z.infer<typeof RpcVerbMap[Verb]["tqkSchema"]>;

export const setlistPacketConsumersByVerb = {
	{{- range $_, $svc := $services }}
		{{- range $_, $method := $svc.Methods }}
			{{- if and (gt (len $method.Outputs) 0) (hasPrefix $method.Name "Watch") }}
				{{- $cacheEntryTypeName := print $method.Name "Return"	}}
				{{- $verb := trimPrefix $method.Name "Watch" }}
				{{- $returnSingleton := index $method.Outputs 0 }}
				{{- $returnPayloadType := $returnSingleton.Type }}
				{{- $returnEnvelope := $returnSingleton.Name }}
				{{- $returnElemTypeName := trimPrefix $returnSingleton.Type.Expr "[]" }}
				{{- if hasKey $typeMap $returnElemTypeName }}
					{{ $returnElemTypeName = get $typeMap $returnElemTypeName }}
				{{- end }}
				{{- $setlistPayloadType := "DEADBEEF" }}
				{{- $multiplicity := "" }}
				{{- if isListType $returnPayloadType }}
					{{- $setlistPayloadType = $returnPayloadType.List.Elem }}
					{{- $multiplicity = "multi" }}
				{{- else }}
					{{- $setlistPayloadType = $returnPayloadType }}
					{{- $multiplicity = "single" }}
				{{- end }}
				{{- $setlistPayloadSchema := print $returnElemTypeName }}
				{{- $returnSchema := print $method.Name "Return" }}
				{{- $hasInput := gt (len $method.Inputs) 0 }}
	{{$verb}}: (tqc: QueryClient, rawTqk: QueryKey, rawPacket: WiredSetlistPacket) => {
		const vrec = RpcVerbMap["{{$verb}}"];
		const tqk = vrec.tqkSchema.parse(rawTqk);
		type CacheEntryT = {{$cacheEntryTypeName}};
		const deltaSchema = RpcTypeMap["{{$returnElemTypeName}}"].deltaTransitionSchema;
		const deltaZprv = deltaSchema.safeParse(rawPacket);
		const cacheEntry = tqc.getQueryData<CacheEntryT>(tqk);
		const cachePayload = cacheEntry ? cacheEntry.{{$returnEnvelope}} : undefined;
		const seal = (letter: unknown) => vrec.returnSchema.parse({ {{- $returnEnvelope -}}: letter});

				{{- if eq $multiplicity "single" }}
		const patchedNext = !!cachePayload && deltaZprv.success
			? {{$setlistPayloadSchema}}.parse(applyPatch(cachePayload, deltaZprv.data))
			: undefined;

		if (!("next" in rawPacket) || !rawPacket.next
			|| (deltaZprv.success && !patchedNext)) {
			void tqc.invalidateQueries({queryKey: tqk});
			return
		}
		// at this point, three possible things can be happening:
		// - an addition
		// - a full replace
		// - a delta that has been inflated
		const next = patchedNext ?? {{$setlistPayloadSchema}}.parse(rawPacket.next);
		const sealedNext = seal(next);
		tqc.setQueryData<CacheEntryT>(tqk, sealedNext);
				{{- else }}{{/* is a list */}}
		if (isNukePacket(rawPacket)) {
			void tqc.invalidateQueries({queryKey: tqk});
		}

		if ("prev" in rawPacket && rawPacket.prev && !("next" in rawPacket)) {
			// a delete
			const prevId = Ided.parse(rawPacket.prev).id;
			if (cachePayload) {
				const next = cachePayload.filter(maybe => maybe.id !== prevId);
				const sealedNext = seal(next);
				tqc.setQueryData<CacheEntryT>(tqk, sealedNext);
			}
		} else {
			// at this point, next must exist and we have the same three-pronged situation.
			// we need set behavior, so we don't blindly add things that we are told to add.
			// so basically we are updating our entry with the relevant id or adding a new
			// one if we don't find one.

			const wantedId = Ided.parse(rawPacket.next).id;
			let found = false;
			const next: {{$returnElemTypeName}}[] = [];
			for (const elem of (cachePayload ?? [])) {
				if (elem.id === wantedId) {
					const newElem = {{$setlistPayloadSchema}}.parse(
						deltaZprv.success ? applyPatch(elem, deltaZprv.data) : rawPacket.next);
					next.push(newElem);
					found = true;
				} else {
					next.push(elem);
				}
			}

			if (!found) {
				if (deltaZprv.success) {
					// no bueno, we have nothing to patch from
					void tqc.invalidateQueries({queryKey: tqk});
				}
				const newElem = {{$setlistPayloadSchema}}.parse(rawPacket.next);
				next.push(newElem);
			}

			const sealedNext = seal(next);
			tqc.setQueryData<CacheEntryT>(tqk, sealedNext);
		}
				{{- end }}
	},
			{{- end }}
		{{- end }}
	{{- end }}
} as const;

{{- end }}

{{- end }}
